import fetch from 'node-fetch';

import type { ChunkExtractor } from '@loadable/server';

export interface ModuleFederationRemotes {
  // name of module federation container
  name: string;
  // URI to federation-stats.json generated by FederationStatsPlugin
  federationStats: string;
  publicHost: string;
}

export const createScriptTag = (chunk: string) => `<script defer src="${chunk}"></script>`;

export const createStyleTag = (chunk: string) => `<link href="${chunk}" type="text/css" rel="stylesheet">`;

export function extractFederatedChunks(
  federationRemotes: ModuleFederationRemotes | ModuleFederationRemotes[]
) {
  const _federationRemotes = Array.isArray(federationRemotes) ? federationRemotes : [federationRemotes];

  const mfAppNames = _federationRemotes.map((remote) => remote.name).join('|');
  const mfAppNamesRegex = RegExp(`(${mfAppNames})-.*`);

  const mfStatsUrlMap = _federationRemotes.reduce(
    (memo, remote) => Object.assign(memo, { [remote.name]: remote.federationStats }),
    {}
  );
  const mfPublicHost = _federationRemotes.reduce(
    (memo, remote) => Object.assign(memo, { [remote.name]: remote.publicHost }),
    {} as Record<string, string>
  );

  const isMfComponent = (component: string) => mfAppNamesRegex.test(component);

  /**
   * @param {Object} extractor - loadable-components extractor
   * @return {string[]} chunk ids of the rendered components.
   */
  const getLoadableRequiredComponents = (extractor: ChunkExtractor) => {
    const loadableElement = extractor
      .getScriptElements()
      .find((el) => el.key === '__LOADABLE_REQUIRED_CHUNKS___ext');

    if (loadableElement) {
      const { namedChunks } = JSON.parse((loadableElement.props as any).dangerouslySetInnerHTML.__html);
      return namedChunks;
    }

    return {};
  };

  const getMfRenderedComponents = (loadableRequiredComponents: string[]) =>
    loadableRequiredComponents.reduce((result, component) => {
      if (isMfComponent(component)) {
        result.push(component.split('-'));
      }
      return result;
    }, [] as string[][]);

  const getMFStats = async () => {
    const promises = Object.values(mfStatsUrlMap).map((url) =>
      fetch(url as string)
        .then((response) => {
          // eslint-disable-next-line no-console
          console.log(`GET: ${url} - ${response.ok} ${response.status}`);
          return response.json();
        })
        // eslint-disable-next-line no-console
        .catch((err) => console.error(`MF: can't fetch ${url}`, err))
    );
    return Promise.all(promises.map((p) => p.catch(() => null))).then((responses) =>
      responses?.filter((data) => !!data)
    );
  };

  const getMfChunks = async (extractor: ChunkExtractor) => {
    const loadableRequiredComponents = getLoadableRequiredComponents(extractor);

    const mfRenderedComponents = getMfRenderedComponents(loadableRequiredComponents);

    const mfChunks = await getMFStats();

    const scriptsArr: string[] = [];
    const stylesArr: string[] = [];
    mfRenderedComponents.forEach(([appName, component]) => {
      if (mfChunks.length === 0) {
        // eslint-disable-next-line no-console
        console.warn(`${appName}: could not find a remote for ${component}`);
        return;
      }
      const remoteStats = mfChunks.find((remote) => remote.name === appName);
      remoteStats.exposes[component].forEach(({ chunk }: { chunk: string }) => {
        const url = `${mfPublicHost[appName]}/${chunk}`;

        // eslint-disable-next-line no-unused-expressions
        url.endsWith('.css') ? stylesArr.push(url) : scriptsArr.push(url);
      });
    });

    return [scriptsArr, stylesArr];
  };

  return { getMfChunks };
}
